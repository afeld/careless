var path = require('path'),
    sys = require('sys'),   
    assert = require('assert'),
    events = require('events'),
    http = require('http'), 
    fs = require('fs'); 

require.paths.unshift(path.join(__dirname, '..', 'lib'));

var vows = require('vows'); 

var resourcer = require('resourcer');

var connection = new(resourcer.engines.memory.Connection)('cache-test').load([
    { resource: 'Article', title: 'The Great Gatsby', published: true,  author: 'fitzgerald'},    
    { resource: 'Article', title: 'Finding vim',      published: false, author: 'cloudhead' },    
    { resource: 'Article', title: 'Channeling force', published: true,  author: 'yoda' },    
    { resource: 'Body',    name: 'fitzgerald' }
]);

vows.describe('resourcer/engine').addBatch({ 
    "resourcer.use": {
        "with an engine passed": {
            topic: function () {
                return resourcer.define('factory')
                                .use(resourcer.engines.memory);
            },
            "should set the engine accordingly": function (Factory) {
                assert.equal (Factory.engine, resourcer.engines.memory);
            }
        },
        "with an engine name": {
            topic: function () {
                return resourcer.define('factory').use('memory');
            },
            "should set the engine accordingly": function (Factory) {
                assert.equal (Factory.engine, resourcer.engines.memory);
            }
        },
        "with an invalid engine": "pending",
        "with an unrecognized engine name": "pending" 
    }
}).addBatch({
    "Connecting": {
        topic: function () {
            return resourcer.define('factory').use('memory').connect();
        },
        "should initialize the connection": function (Factory) {
           assert.instanceOf (Factory.connection, resourcer.engines.memory.Connection);
        }
    },
    "Global settings": {
        topic: function () {
            this.engine = { Connection: function (_) {} };
            resourcer.use(this.engine);
            return resourcer.define('factory');
        },
        "should trickle down to resources": function (Factory) {
            assert.equal (Factory.engine, this.engine);
        }
    },
    "Connecting with a URI": {
        topic: function () {
            return resourcer.define('factory').connect('memory://le-special-uri');
        },
        "should set the storage name properly": function (Factory) {
            assert.equal (Factory.connection.uri, 'le-special-uri');
        }
    }
}).addBatch({
    "Foo": {
        topic: function () {
            resourcer.use('memory');

            new(resourcer.engines.memory.Connection)('Person').load({
                1: { _id: 1, name: 'Peter', age: 30}
            }); 
            return resourcer.define('Person');
        },
        "should be resource": function (Person) {
            assert.equal (Person.resource, 'Person');
        },
        "Create": {
            topic: function (Person) {
                this.Person = Person;
                Person.create({_id: 2, name: "Lori", age: 10 }, this.callback);
            },
            "Should provide a valid event": function (err, ev) {
                assert.isNull(err);
                assert.instanceOf(ev, this.Person);
            }
        },
        "Find": {
            topic: function (Person) {
                Person.find({name: "Peter"}, this.callback);
            },
            "Should extract Peter": function(err, results){
                assert.isNull(err);
                assert.instanceOf(results, Array);
                assert.length(results, 1);
            }
        }
    }
}).export(module);
