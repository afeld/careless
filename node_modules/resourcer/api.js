resource.Task = function (prototype) {
    //
    // Specify the name of the resource, if different
    // than the file name. (optional)
    //
    this.name("Task");
    
    //
    // Creates a new property on Task, called 'title'
    //
    // Generates JSON Schema
    //
    // The equivalence isn't necessarly 1-to-1
    //
    // Property options/validators can be specified as a hash,
    // and/or through method calls. Usually, the later is used
    // when you need to pass options (via an object) or conditions
    // in which these validators are triggered (via a function).
    //
    this.property('title', String, {
        unique: true,
        assert: function (title) { return title !== 'tommy' },
        length: [0, 20],
        format: /[a-z a-z]+/
    }).unique({ message: "Please choose a unique title", scope: 'project' })
      .format({ message: "The format for your title is invalid" })
      .required({ condition: function (task) { return task.description } });

    //
    // Equivalent to the above
    //
    this.property('title', String, function (t) {
        t.unique({ message: "Please choose a unique title", scope: 'project' });
        t.format(/[A-Z a-z]+/, { message: "The format for your title is invalid" });
        t.required(function (task) { return task.description }, {});
    });

    //
    // Contextual validations
    //
    // We can group validators by 'context'. When saving or validating,
    // we specify an optional context, which activates the relevant validators.
    //
    this.properties.title.required({context: ['draft', 'final']});
    this.properties.description.required({context: 'final'});

    // Save as 'final'
    //
    // This will trigger both above validations
    //
    task.save('final');

    // Check if this is a valid 'draft'
    task.isValid('draft');

    this.scope('publishedSince', function (date) {
        return function (doc) {
            
        }; 
    });
    
    //
    // Equivalent to `this.property('description').type('string')`
    //
    this.property('description', String);

    //
    // Equivalent to:
    //
    //     this.property('date').type('string').format('date')
    //
    this.property('date', Date);

    this.property('status').type('number');

    //
    // Alternatively, you can use the `schema` function,
    // to define the resource's properties and constraints.
    //
    this.schema({ name: 'task' });

    //
    // The `schema` function can also be used per-property
    //
    this.property('priority').schema({ type: 'number', minimum: 0 }).unique();

    //
    // Access the 'title' property definition
    //
    this.properties.title;

    //
    // Set the title property to be unique
    //
    this.properties.title.unique = true;

    //
    // HTML Sanitization module
    //
    this.sanitize('title', 'description');

    //
    // Add an after filter to `create`
    //
    this.create.after(function (obj) {
        log('created ' + inspect(obj)); 
    });
    
    this.watcher('beforeCreate', function (obj) {
        log('about to create ' + inspect(obj)); 
    });
    this.create.addWatcher('begin', function (obj) {
        log('about to create ' + inspect(obj)); 
    });
    this.create.addWatcher('success', function (obj) {
        log('created ' + inspect(obj)); 
    });
    this.create.addWatcher('error', function (obj) {
        log('error creating ' + inspect(obj)); 
    });

    this.addListener('', function () {
    
    });

    this.create.addWatcher('error', {
        before: function () {}
        after: function () {}
    });
    this.create.preFilter('error', function () {
    
    });
    this.create.addListener('beforeSuccess', function () {
    
    });

    this.addPreListener(/save/, )
    this.addPostListener(/save/, )
    'preCreate'
    'preSave'
    'postCreate'
    'postSave'
    'error'
    'validate'

    this.events('success')

    this.addListener('preSave', function (o) {
        resourcer.cache.set(o.id, o);
    });

    //
    // Alternatively, one can watch for *all* events
    //
    this.addWatcher('event', function (event, obj) {});

    // Here, we're watching for all events, but only
    // logging the ones by author 42
    this.subscribe(function (event, obj) {
        if (obj.match({ author: 42 })) {
           log.event(event, obj);
        }
    });
    this.feed;   // [...] // An array of ['event', <object>]
    this.events; // alternative naming

    // The array of create's after filters.
    this.create.filters.after; // [ function (obj) {...} ]
    this.create.filters;       // { before: [...], after: [...] }

    // Filters run before & after validation
    this.validate.filters;

    //
    // Instance methods
    //
    this.prototype.start = function () {};
    prototype.start = function () {};
};

resource.Type.prototype = {
    this.prototype.start = function () {
        task.update({status: 1});
    }
};

